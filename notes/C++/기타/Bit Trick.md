```cpp
// mask의 부분집합들 중 공집합만 제외하고 전부 순회
for (int i = mask; i > 0; i = (i - 1) & mask){
    cout << mask << "(" << bitset<N>(mask) << ") " << bitset<N>(i) << "\n";
}

// ex) mask = 11101
// 29(11101) 11101
// 29(11101) 11100
// 29(11101) 11001
// 29(11101) 11000
// 29(11101) 10101
// 29(11101) 10100
// 29(11101) 10001
// 29(11101) 10000
// 29(11101) 01101
// 29(11101) 01100
// 29(11101) 01001
// 29(11101) 01000
// 29(11101) 00101
// 29(11101) 00100
// 29(11101) 00001

// nCr 비트마스크 순회
constexpr int n = 5, k = 3;
for (int mask = (1 << k) - 1; mask < (1 << n); ) { // n개 비트 중 k개 비트만 켜진 모든 비트마스크를 오름차순으로 순회
    if (mask == 0) break;
    // code
    cout << bitset<n>(mask) << "\n";
    int x = mask & -mask, y = mask + x;
    mask = ((mask & ~y) / x >> 1) | y;
}

// 00111
// 01011
// 01101
// 01110
// 10011
// 10101
// 10110
// 11001
// 11010
// 11100
```
$\because$   
`x = mask & -mask` : mask에서 가장 오른쪽 1비트   
`y = mask + x` : mask에서 가장 오른쪽 1비트에 1을 더함   
`mask & ~y` : mask에서 가장 오른쪽 1비트와 인접한 1비트들만을 남긴 것   
`(mask & ~y) / x` : mask에서 가장 오른쪽 1비트가 2^0자리 비트에 위치하도록 쉬프트(즉, mask에서 가장 오른쪽 1비트부터 왼쪽으로 연속한 1비트의 개수가 n개일 때 `(1<<n) - 1`과 같음)   
`(mask & ~y) / x >> 1` : 한 번 더 오른쪽으로 쉬프트   
`((mask & ~y) / x >> 1) | y` : y랑 합침   

`mask`가 `{비트들}0{최우측1비트와 인접한 비트들}{0개 이상의 0비트들}` 구조일 때
`((mask & ~y) / x >> 1) | y`는 `{비트들}1{0개 이상의 0비트들}{최우측1비트와 인접한 비트들 에서 맨앞 1비트만 0으로 바꾼 것}`   

ex)   
mask = 10110   
x = 00010   
y = 11000   
mask & ~y = 00110   
(mask & ~y) / x = 00011   
(mask & ~y) / x >> 1 = 00001   
((mask & ~y) / x >> 1) | y = 11001   